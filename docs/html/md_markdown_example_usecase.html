<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WaSH Docs: Example Simulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WaSH Docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Example Simulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>WaSH allows for arbitrary orderings of kernel functions in order to simulate a large variety of SPH scenarios.</p>
<p>This page describes how one can use WaSH to create a basic water simulation. A finished version of this example may be found in the WaSH source code as the <code>ca_fluid_sim</code> example.</p>
<h1>Constants</h1>
<p>Some constants are defined before starting the simulation for easy parameter tweaking. Here's what constants should be defined at the top: </p><div class="fragment"><div class="line">constexpr <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> spawnCentre { 3.35, 0.51 };</div><div class="line">constexpr <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> initialVelocity { 0.0, 0.0 };</div><div class="line">constexpr <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> spawnSize { 7.0, 7.0 };</div><div class="line">constexpr <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> boundsSize { 17.1, 9.3 };</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">double</span> jitterStr = 0.025;</div><div class="line">constexpr <span class="keywordtype">double</span> numParticles = 4032;</div><div class="line">constexpr <span class="keywordtype">double</span> gravity = -12.0;</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">double</span> deltaTime = TIME_DELTA(1, 3);</div><div class="line">constexpr <span class="keywordtype">double</span> collisionDamping = 0.95;</div><div class="line">constexpr <span class="keywordtype">double</span> smoothingRadius = 0.35;</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">double</span> targetDensity = 55.0;</div><div class="line">constexpr <span class="keywordtype">double</span> pressureMultiplier = 500.0;</div><div class="line">constexpr <span class="keywordtype">double</span> nearPressureMultiplier = 18.0;</div><div class="line">constexpr <span class="keywordtype">double</span> viscosityStrength = 0.06;</div></div><!-- fragment --><h1>Initialising Common Parameters</h1>
<p>The first step is to set some parameters for your simulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    wash::set_precision(<span class="stringliteral">&quot;double&quot;</span>);</div><div class="line">    wash::set_influence_radius(smoothingRadius);</div><div class="line">    <a class="code" href="namespacewash.html#aeb7b287406244c8ab192d0524ad4da5b">wash::set_max_iterations</a>(1000);</div><div class="line">}</div></div><!-- fragment --><h1>Outputs</h1>
<p>The simulation results must be written <em>somewhere</em>. WaSH provides API calls for specifying what file to output to: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    ...</div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 1) {</div><div class="line">        <span class="comment">// argv[1] = simulation name</span></div><div class="line">        <a class="code" href="namespacewash.html#a4ddbab848bef96e0fc69bf8e280d4775">wash::set_simulation_name</a>(argv[1]);</div><div class="line">        <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">            <span class="comment">// argv[2] = output file name</span></div><div class="line">            <a class="code" href="namespacewash.html#ad6de17b9a27f58f6245a68ede303e84b">wash::set_output_file_name</a>(argv[2]);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="namespacewash.html#ad6de17b9a27f58f6245a68ede303e84b">wash::set_output_file_name</a>(<span class="stringliteral">&quot;ca&quot;</span>);</div><div class="line">        }</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="namespacewash.html#a4ddbab848bef96e0fc69bf8e280d4775">wash::set_simulation_name</a>(<span class="stringliteral">&quot;serial_test&quot;</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1>Forces</h1>
<p>A 'Force' in this case is not necessarily a force, but could be a particle's <em>property</em> for example temperature, that some other simulations may want to use for their calculations. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    ...</div><div class="line">    wash::add_force(<span class="stringliteral">&quot;nearDensity&quot;</span>, 1);</div><div class="line"></div><div class="line">    wash::add_force(<span class="stringliteral">&quot;predictedPosition&quot;</span>, 2);</div><div class="line">    wash::add_force(<span class="stringliteral">&quot;pressure&quot;</span>, 2);</div><div class="line">}</div></div><!-- fragment --><p> These forces are now tracked for each particle in the simulation and may be used within kernel functions.</p>
<h1>Kernels</h1>
<p>The kernels that describe the specific computations to take place in the simulation must be registered with WaSH.</p>
<h2>Initialisation Kernel</h2>
<p>Your simulation must have a starting state for your particles. This is done like so: </p><div class="fragment"><div class="line">wash::add_init_kernel(&amp;init);</div></div><!-- fragment --><p> When the simulation starts, it will use whatever is defined in the <code>init</code> function. The contents of the <code>init</code> function may look like this if your goal is to spawn uniformly distributed particles: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> init() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Calculated Time Step: &quot;</span> &lt;&lt; deltaTime &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    SpawnParticles(spawnSize, numParticles);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> SpawnParticles(<span class="keyword">const</span> <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> spawnSizeVec, <span class="keyword">const</span> <span class="keywordtype">size_t</span> particleCount) {</div><div class="line">    std::uniform_real_distribution&lt;double&gt; unif(0.0, 1.0);</div><div class="line">    std::default_random_engine re(42);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> s_x = spawnSizeVec.at(0);</div><div class="line">    <span class="keywordtype">double</span> s_y = spawnSizeVec.at(1);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> numX = (int)std::ceil( std::sqrt(</div><div class="line">        s_x / s_y * particleCount + (s_x - s_y) * (s_x - s_y) / (4 * s_y * s_y)</div><div class="line">    ) - (s_x - s_y) / (2 * s_y));</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> numY = (int)std::ceil( (<span class="keywordtype">double</span>)particleCount / (double)numX );</div><div class="line">    <span class="keywordtype">int</span> i = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; numY; y++) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; numX; x++) {</div><div class="line">            <span class="keywordflow">if</span> (i &gt;= particleCount) <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> tx = numX &lt;= 1 ? 0.5 : x / (numX - 1.0);</div><div class="line">            <span class="keywordtype">double</span> ty = numY &lt;= 1 ? 0.5 : y / (numY - 1.0);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> angle = unif(re) * PI * 2.0;</div><div class="line">            <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> dir = <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a>({ std::cos(angle), std::sin(angle) });</div><div class="line">            <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> jitter = dir * jitterStr * (unif(re) - 0.5);</div><div class="line">            <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> pos = <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a>({ (tx - 0.5) * s_x, (ty - 0.5) * s_y }) + jitter + spawnCentre;</div><div class="line"></div><div class="line">            <span class="comment">// wash::Particle newp = wash::Particle();</span></div><div class="line">            <span class="comment">// newp.set_force_vector(&quot;position&quot;, newp.get_pos());</span></div><div class="line">            <span class="comment">// newp.set_vel(initialVelocity);</span></div><div class="line">            <span class="comment">// // VelocityUpdate(newp); // call here as the first initial call before density kernel</span></div><div class="line">            <span class="comment">// wash::add_par(newp);</span></div><div class="line">            <span class="keyword">auto</span>&amp; p = wash::create_particle(0.0, 1.0, smoothingRadius, pos, initialVelocity);</div><div class="line">            p.set_force_vector(<span class="stringliteral">&quot;position&quot;</span>, pos);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (i &lt; 5) {</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Particle &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; position &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;</div><div class="line">            }</div><div class="line"></div><div class="line">            i++;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2>Force and Update Kernels</h2>
<p>These kernels define how particles change. The registration order of these kernels is order-sensitive, meaning they are run (at each iteration) in the order specified. Here's how we will order our force kernels: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    ...</div><div class="line">    <a class="code" href="namespacewash.html#abc27c958fb1156da77a1346c3559abc1">wash::add_update_kernel</a>(&amp;VelocityUpdate);</div><div class="line">    <a class="code" href="namespacewash.html#a2ffa21a9e32d3ca6ce87def3e7db4837">wash::add_force_kernel</a>(&amp;CalculateDensity);</div><div class="line">    <a class="code" href="namespacewash.html#a2ffa21a9e32d3ca6ce87def3e7db4837">wash::add_force_kernel</a>(&amp;force_kernel);</div><div class="line"></div><div class="line">    <a class="code" href="namespacewash.html#abc27c958fb1156da77a1346c3559abc1">wash::add_update_kernel</a>(&amp;UpdatePositions);</div><div class="line">    <a class="code" href="namespacewash.html#abc27c958fb1156da77a1346c3559abc1">wash::add_update_kernel</a>(&amp;HandleCollisions);</div><div class="line"></div><div class="line">    <a class="code" href="namespacewash.html#a4c8a9913a535b341da9e72826916544b">wash::start</a>();</div><div class="line">}</div></div><!-- fragment --><p> This is the last part of our Main function. It describes the high-level behaviour of the simulation, and all that's left is the low-level specification of what should happen in each kernel.</p>
<p>Notice that the kernels are to be specified for <em>one</em> particle. WaSH will take care of the looping and parallelisation.</p>
<h3>VelocityUpdate Implementation</h3>
<p>This kernel function helps us predict where the particle will be in the next timestep. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> VelocityUpdate(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle) {</div><div class="line">    particle.set_vel(particle.get_vel() + ExternelForces(particle.get_pos(), particle.get_vel()) * deltaTime);</div><div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Particle velocity: &quot; &lt;&lt; particle.get_vel() &lt;&lt; std::endl;</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> predictionFactor = 1 / 120.0;</div><div class="line">    <span class="comment">// set predicted pos to the real position + some timestep of current vel</span></div><div class="line">    particle.set_pos(particle.get_force_vector(<span class="stringliteral">&quot;position&quot;</span>) + particle.get_vel() * predictionFactor);</div><div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Particle pred pos: &quot; &lt;&lt; particle.get_pos() &lt;&lt; std::endl;</span></div><div class="line">}</div></div><!-- fragment --><h3>CalculateDensity Implementation</h3>
<p>Calculating density of particles is common across most, if not all, SPH simulations. Here's how we'll define it for our example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CalculateDensity(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle, <span class="keyword">const</span> std::vector&lt;wash::Particle&gt;&amp; neighbours) {</div><div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Running Custom Density Func&quot; &lt;&lt; std::endl;</span></div><div class="line">    <span class="keywordtype">double</span> density = 1.0;</div><div class="line">    <span class="keywordtype">double</span> nearDensity = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; neighbour : neighbours) {</div><div class="line">        <span class="keyword">auto</span> offset = neighbour.get_pos() - particle.get_pos();</div><div class="line">        <span class="keywordtype">double</span> dst = offset.magnitude();</div><div class="line"></div><div class="line">        density += DensityKernel(dst, smoothingRadius);</div><div class="line">        nearDensity += NearDensityKernel(dst, smoothingRadius);</div><div class="line">    }</div><div class="line"></div><div class="line">    particle.set_density(density);</div><div class="line">    particle.set_force_scalar(<span class="stringliteral">&quot;nearDensity&quot;</span>, nearDensity);</div><div class="line">}</div></div><!-- fragment --><h3>force_kernel Implementation</h3>
<p>Here, forces are applied to particles to simulate incompressible fluid with some viscosity. In this case, we want something resembling water. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> force_kernel(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle, <span class="keyword">const</span> std::vector&lt;wash::Particle&gt;&amp; neighbours) {</div><div class="line">    CalculatePressureForce(particle, neighbours);</div><div class="line">    CalculateViscosity(particle, neighbours);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> CalculatePressureForce(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle, <span class="keyword">const</span> std::vector&lt;wash::Particle&gt;&amp; neighbours) {</div><div class="line">    <span class="keywordtype">double</span> density = particle.get_density();</div><div class="line">    <span class="keywordtype">double</span> nearDensity = particle.get_force_scalar(<span class="stringliteral">&quot;nearDensity&quot;</span>);</div><div class="line">    <span class="keywordtype">double</span> pressure = PressureFromDensity(density);</div><div class="line">    <span class="keywordtype">double</span> nearPressure = NearPressureFromDensity(nearDensity);</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> pressureForce = <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a>({0.0, 0.0});</div><div class="line"></div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> pos = particle.get_pos();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; neighbour : neighbours) {</div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> neighbourPos = neighbour.get_pos();</div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> offsetToNeighbour = neighbourPos - pos;</div><div class="line">        <span class="keywordtype">double</span> dst = offsetToNeighbour.magnitude();</div><div class="line"></div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> dirToNeighbour = dst &gt; 0.0 ? offsetToNeighbour / dst : <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a>({0.0, 1.0});</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> neighbourDensity = neighbour.get_density();</div><div class="line">        <span class="keywordtype">double</span> neighbourNearDensity = neighbour.get_force_scalar(<span class="stringliteral">&quot;nearDensity&quot;</span>);</div><div class="line">        <span class="keywordtype">double</span> neighbourPressure = PressureFromDensity(neighbourDensity);</div><div class="line">        <span class="keywordtype">double</span> neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> sharedPressure = (pressure + neighbourPressure) * 0.5;</div><div class="line">        <span class="keywordtype">double</span> sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;</div><div class="line"></div><div class="line">        pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;</div><div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;w density p &quot; &lt;&lt; pressureForce &lt;&lt; std::endl;</span></div><div class="line">        pressureForce +=</div><div class="line">            dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;</div><div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;w near density p &quot; &lt;&lt; pressureForce &lt;&lt; std::endl;</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> acceleration = pressureForce / density;</div><div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;PRESSURE FORCE p&quot; &lt;&lt; pressureForce &lt;&lt; std::endl;</span></div><div class="line"></div><div class="line">    particle.set_force_vector(<span class="stringliteral">&quot;pressure&quot;</span>, pressureForce / density);</div><div class="line">    particle.set_vel(particle.get_vel() + acceleration * deltaTime);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> CalculateViscosity(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle, <span class="keyword">const</span> std::vector&lt;wash::Particle&gt;&amp; neighbours) {</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> pos = particle.get_pos();</div><div class="line"></div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> viscosityForce = <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> { 0.0, 0.0 };</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> velocity = particle.get_vel();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; neighbour : neighbours) {</div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> neighbourPos = neighbour.get_pos();</div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> offsetToNeighbour = neighbourPos - pos;</div><div class="line">        <span class="keywordtype">double</span> dst = offsetToNeighbour.magnitude();</div><div class="line"></div><div class="line">        <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> neighbourVelocity = neighbour.get_vel();</div><div class="line">        viscosityForce += (neighbourVelocity - velocity) * ViscosityKernel(dst, smoothingRadius);</div><div class="line">    }</div><div class="line"></div><div class="line">    particle.set_force_vector(<span class="stringliteral">&quot;viscosity&quot;</span>, viscosityForce * viscosityStrength);</div><div class="line">    particle.set_vel(particle.get_vel() + viscosityForce * viscosityStrength * deltaTime);</div><div class="line">}</div></div><!-- fragment --><h3>UpdatePositions Implementation</h3>
<p>This one's pretty self-explanatory. Using basic SUVAT to update the particles' positions. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> UpdatePositions(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle) {</div><div class="line">    <span class="comment">// particle.set_pos(particle.get_pos() + particle.get_vel() * deltaTime);</span></div><div class="line">    particle.set_force_vector(<span class="stringliteral">&quot;position&quot;</span>, particle.get_force_vector(<span class="stringliteral">&quot;position&quot;</span>) + particle.get_vel() * deltaTime);</div><div class="line">}</div></div><!-- fragment --><h3>HandleCollisions Implementation</h3>
<p>The HandleCollisions kernel ensures particles do not exit the bounds of the simulation, and instead bounce back against a 'wall' (with a little damping) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> HandleCollisions(<a class="code" href="classwash_1_1Particle.html">wash::Particle</a>&amp; particle) {</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> pos = particle.get_force_vector(<span class="stringliteral">&quot;position&quot;</span>);</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> vel = particle.get_vel();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> halfSize = boundsSize * 0.5;</div><div class="line">    <a class="code" href="classwash_1_1Vec.html">wash::Vec2D</a> edgeDst = halfSize - pos.abs();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (*(edgeDst[0]) &lt;= 0) {</div><div class="line">        *(pos[0]) = halfSize.at(0) * <a class="code" href="namespacewash.html#a706d6d30508a81b6b9f25494cd759dff">wash::sgn</a>(pos.at(0));</div><div class="line">        *(vel[0]) *= -1 * collisionDamping;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (*(edgeDst[1]) &lt;= 0) {</div><div class="line">        *(pos[1]) = halfSize.at(1) * <a class="code" href="namespacewash.html#a706d6d30508a81b6b9f25494cd759dff">wash::sgn</a>(pos.at(1));</div><div class="line">        *(vel[1]) *= -1 * collisionDamping;</div><div class="line">    }</div><div class="line">    <span class="comment">// do any obstacle collision here</span></div><div class="line"></div><div class="line">    particle.set_force_vector(<span class="stringliteral">&quot;position&quot;</span>, pos);</div><div class="line">    particle.set_vel(vel);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
